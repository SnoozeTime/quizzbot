/// CLASS WAS AUTOGENERATED  - DO NOT MODIFY

#pragma once
#include <sstream>
#include <string>

#include "common/message.h"
#include "common/quizzbot_types.h"

namespace quizzbot {
class AnswerMessage : public MessageData {
public:
  AnswerMessage() = default;

  AnswerMessage(std::string from, std::string answer)
      :

        from_(std::move(from)),

        answer_(std::move(answer)) {}

  // Default move because the types should be trivials..
  AnswerMessage(AnswerMessage &&other) noexcept = default;
  AnswerMessage &operator=(AnswerMessage &&other) = default;

  MessageType message_type() override { return MessageType::ANSWER; }

  void unpack(std::string &ss) override {

    size_t offset = 0;

    {
      auto oh = msgpack::unpack(ss.c_str(), ss.size(), offset);
      auto o = oh.get();
      from_ = o.as<std::string>();
    }

    {
      auto oh = msgpack::unpack(ss.c_str(), ss.size(), offset);
      auto o = oh.get();
      answer_ = o.as<std::string>();
    }
  }

  void pack(std::stringstream &ss) override {

    msgpack::pack(ss, from_);

    msgpack::pack(ss, answer_);
  }

  // Then Getters and setters

  void set_from(const std::string &from) { from_ = from; }
  const std::string &from() const { return from_; }

  void set_answer(const std::string &answer) { answer_ = answer; }
  const std::string &answer() const { return answer_; }

  // double dispatch to avoid casting.
  //  void dispatch(MessageHandler* handler) override {
  //  handler->handle(*this);
  //}

private:
  std::string from_{};

  std::string answer_{};
};
}